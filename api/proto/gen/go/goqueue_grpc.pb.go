// =============================================================================
// GOQUEUE PROTOCOL BUFFER DEFINITIONS
// =============================================================================
//
// WHAT IS THIS?
// Protocol Buffers (protobuf) define the contract for gRPC communication.
// Think of it like a schema for binary serialization - strongly typed,
// compact, and language-agnostic.
//
// WHY PROTOCOL BUFFERS?
//
//   ┌─────────────────────────────────────────────────────────────────────────┐
//   │ JSON                          │ Protocol Buffers                        │
//   ├───────────────────────────────┼─────────────────────────────────────────┤
//   │ {"topic": "orders"}           │ 0a 06 6f 72 64 65 72 73                 │
//   │ Human readable                │ Binary (10x smaller)                    │
//   │ Schema optional               │ Schema required (good!)                 │
//   │ No code generation            │ Auto-generates client/server code       │
//   │ Parse at runtime              │ Zero-copy deserialization possible      │
//   └───────────────────────────────┴─────────────────────────────────────────┘
//
// FILE ORGANIZATION:
// This single file defines all goqueue gRPC services. We keep it monolithic
// for simplicity - split into multiple files if it grows beyond ~500 lines.
//
// SERVICES DEFINED:
//   1. PublishService   - Publish messages (unary + streaming)
//   2. ConsumeService   - Stream messages to consumers (server streaming)
//   3. AckService       - Acknowledge messages (unary)
//   4. OffsetService    - Commit/fetch offsets (unary)
//
// FIELD NUMBERING RULES:
//   - Numbers 1-15 use 1 byte on wire (use for frequent fields)
//   - Numbers 16-2047 use 2 bytes
//   - Never reuse field numbers (for backwards compatibility)
//   - Mark deprecated fields with [deprecated = true]
//
// COMPARISON WITH OTHER SYSTEMS:
//   - Kafka: Custom binary protocol (Kafka protocol)
//   - Pulsar: Uses protobuf internally
//   - NATS: Simple text protocol + protobuf option
//   - RabbitMQ: AMQP binary protocol
//   - goqueue: gRPC/protobuf (modern, well-tooled)
//
// =============================================================================

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: goqueue.proto

package goqueuev1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	PublishService_Publish_FullMethodName       = "/goqueue.v1.PublishService/Publish"
	PublishService_PublishStream_FullMethodName = "/goqueue.v1.PublishService/PublishStream"
)

// PublishServiceClient is the client API for PublishService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PublishServiceClient interface {
	// Publish - Single message publish with immediate acknowledgment
	//
	// FLOW:
	//
	//	Client ─── PublishRequest ───► Server
	//	Client ◄── PublishResponse ─── Server
	//
	// LATENCY: ~1-5ms (includes disk fsync if acks=leader)
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error)
	// PublishStream - Bidirectional streaming for high-throughput publishing
	//
	// FLOW:
	//
	//	Client ═══ PublishStreamRequest 1 ═══►
	//	Client ═══ PublishStreamRequest 2 ═══►  Server
	//	Client ◄══ PublishStreamResponse 1 ═══
	//	Client ═══ PublishStreamRequest 3 ═══►
	//	Client ◄══ PublishStreamResponse 2,3 ═
	//
	// The server batches ACKs and sends them periodically or when buffer fills.
	// This allows the client to keep sending without waiting for each ACK.
	//
	// FLOW CONTROL:
	// gRPC HTTP/2 has built-in flow control. If the server is slow, the client
	// will automatically slow down (backpressure). No manual implementation needed!
	PublishStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[PublishStreamRequest, PublishStreamResponse], error)
}

type publishServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPublishServiceClient(cc grpc.ClientConnInterface) PublishServiceClient {
	return &publishServiceClient{cc}
}

func (c *publishServiceClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishResponse)
	err := c.cc.Invoke(ctx, PublishService_Publish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publishServiceClient) PublishStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[PublishStreamRequest, PublishStreamResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PublishService_ServiceDesc.Streams[0], PublishService_PublishStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[PublishStreamRequest, PublishStreamResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PublishService_PublishStreamClient = grpc.BidiStreamingClient[PublishStreamRequest, PublishStreamResponse]

// PublishServiceServer is the server API for PublishService service.
// All implementations must embed UnimplementedPublishServiceServer
// for forward compatibility.
type PublishServiceServer interface {
	// Publish - Single message publish with immediate acknowledgment
	//
	// FLOW:
	//
	//	Client ─── PublishRequest ───► Server
	//	Client ◄── PublishResponse ─── Server
	//
	// LATENCY: ~1-5ms (includes disk fsync if acks=leader)
	Publish(context.Context, *PublishRequest) (*PublishResponse, error)
	// PublishStream - Bidirectional streaming for high-throughput publishing
	//
	// FLOW:
	//
	//	Client ═══ PublishStreamRequest 1 ═══►
	//	Client ═══ PublishStreamRequest 2 ═══►  Server
	//	Client ◄══ PublishStreamResponse 1 ═══
	//	Client ═══ PublishStreamRequest 3 ═══►
	//	Client ◄══ PublishStreamResponse 2,3 ═
	//
	// The server batches ACKs and sends them periodically or when buffer fills.
	// This allows the client to keep sending without waiting for each ACK.
	//
	// FLOW CONTROL:
	// gRPC HTTP/2 has built-in flow control. If the server is slow, the client
	// will automatically slow down (backpressure). No manual implementation needed!
	PublishStream(grpc.BidiStreamingServer[PublishStreamRequest, PublishStreamResponse]) error
	mustEmbedUnimplementedPublishServiceServer()
}

// UnimplementedPublishServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPublishServiceServer struct{}

func (UnimplementedPublishServiceServer) Publish(context.Context, *PublishRequest) (*PublishResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedPublishServiceServer) PublishStream(grpc.BidiStreamingServer[PublishStreamRequest, PublishStreamResponse]) error {
	return status.Error(codes.Unimplemented, "method PublishStream not implemented")
}
func (UnimplementedPublishServiceServer) mustEmbedUnimplementedPublishServiceServer() {}
func (UnimplementedPublishServiceServer) testEmbeddedByValue()                        {}

// UnsafePublishServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PublishServiceServer will
// result in compilation errors.
type UnsafePublishServiceServer interface {
	mustEmbedUnimplementedPublishServiceServer()
}

func RegisterPublishServiceServer(s grpc.ServiceRegistrar, srv PublishServiceServer) {
	// If the following call panics, it indicates UnimplementedPublishServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PublishService_ServiceDesc, srv)
}

func _PublishService_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublishServiceServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublishService_Publish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublishServiceServer).Publish(ctx, req.(*PublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublishService_PublishStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PublishServiceServer).PublishStream(&grpc.GenericServerStream[PublishStreamRequest, PublishStreamResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PublishService_PublishStreamServer = grpc.BidiStreamingServer[PublishStreamRequest, PublishStreamResponse]

// PublishService_ServiceDesc is the grpc.ServiceDesc for PublishService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PublishService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "goqueue.v1.PublishService",
	HandlerType: (*PublishServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Publish",
			Handler:    _PublishService_Publish_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PublishStream",
			Handler:       _PublishService_PublishStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "goqueue.proto",
}

const (
	ConsumeService_Consume_FullMethodName   = "/goqueue.v1.ConsumeService/Consume"
	ConsumeService_Subscribe_FullMethodName = "/goqueue.v1.ConsumeService/Subscribe"
)

// ConsumeServiceClient is the client API for ConsumeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConsumeServiceClient interface {
	// Consume - Server streaming of messages
	//
	// The stream stays open until:
	//   - Client cancels (context.Cancel)
	//   - Server closes (rebalance, shutdown)
	//   - Error occurs (network, auth)
	//
	// HEARTBEAT:
	// The server sends periodic heartbeat messages (empty, just to keep alive)
	// if no real messages are available. This prevents TCP timeouts.
	Consume(ctx context.Context, in *ConsumeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ConsumeResponse], error)
	// Subscribe - Long-lived subscription with consumer group
	//
	// Unlike Consume, this handles:
	//   - Consumer group membership
	//   - Automatic partition assignment
	//   - Rebalancing notifications
	//
	// FLOW:
	//
	//	Consumer ─── SubscribeRequest ────► Broker (includes group_id)
	//	Consumer ◄── Assignment ──────────  [Which partitions you got]
	//	Consumer ◄── Message 1 ───────────
	//	Consumer ◄── Message 2 ───────────
	//	Consumer ◄── RebalanceStart ──────  [Rebalance triggered]
	//	Consumer ◄── Assignment ──────────  [New assignment]
	//	...
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ConsumeResponse], error)
}

type consumeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConsumeServiceClient(cc grpc.ClientConnInterface) ConsumeServiceClient {
	return &consumeServiceClient{cc}
}

func (c *consumeServiceClient) Consume(ctx context.Context, in *ConsumeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ConsumeResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ConsumeService_ServiceDesc.Streams[0], ConsumeService_Consume_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ConsumeRequest, ConsumeResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConsumeService_ConsumeClient = grpc.ServerStreamingClient[ConsumeResponse]

func (c *consumeServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ConsumeResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ConsumeService_ServiceDesc.Streams[1], ConsumeService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, ConsumeResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConsumeService_SubscribeClient = grpc.ServerStreamingClient[ConsumeResponse]

// ConsumeServiceServer is the server API for ConsumeService service.
// All implementations must embed UnimplementedConsumeServiceServer
// for forward compatibility.
type ConsumeServiceServer interface {
	// Consume - Server streaming of messages
	//
	// The stream stays open until:
	//   - Client cancels (context.Cancel)
	//   - Server closes (rebalance, shutdown)
	//   - Error occurs (network, auth)
	//
	// HEARTBEAT:
	// The server sends periodic heartbeat messages (empty, just to keep alive)
	// if no real messages are available. This prevents TCP timeouts.
	Consume(*ConsumeRequest, grpc.ServerStreamingServer[ConsumeResponse]) error
	// Subscribe - Long-lived subscription with consumer group
	//
	// Unlike Consume, this handles:
	//   - Consumer group membership
	//   - Automatic partition assignment
	//   - Rebalancing notifications
	//
	// FLOW:
	//
	//	Consumer ─── SubscribeRequest ────► Broker (includes group_id)
	//	Consumer ◄── Assignment ──────────  [Which partitions you got]
	//	Consumer ◄── Message 1 ───────────
	//	Consumer ◄── Message 2 ───────────
	//	Consumer ◄── RebalanceStart ──────  [Rebalance triggered]
	//	Consumer ◄── Assignment ──────────  [New assignment]
	//	...
	Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[ConsumeResponse]) error
	mustEmbedUnimplementedConsumeServiceServer()
}

// UnimplementedConsumeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConsumeServiceServer struct{}

func (UnimplementedConsumeServiceServer) Consume(*ConsumeRequest, grpc.ServerStreamingServer[ConsumeResponse]) error {
	return status.Error(codes.Unimplemented, "method Consume not implemented")
}
func (UnimplementedConsumeServiceServer) Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[ConsumeResponse]) error {
	return status.Error(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedConsumeServiceServer) mustEmbedUnimplementedConsumeServiceServer() {}
func (UnimplementedConsumeServiceServer) testEmbeddedByValue()                        {}

// UnsafeConsumeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConsumeServiceServer will
// result in compilation errors.
type UnsafeConsumeServiceServer interface {
	mustEmbedUnimplementedConsumeServiceServer()
}

func RegisterConsumeServiceServer(s grpc.ServiceRegistrar, srv ConsumeServiceServer) {
	// If the following call panics, it indicates UnimplementedConsumeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConsumeService_ServiceDesc, srv)
}

func _ConsumeService_Consume_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConsumeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConsumeServiceServer).Consume(m, &grpc.GenericServerStream[ConsumeRequest, ConsumeResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConsumeService_ConsumeServer = grpc.ServerStreamingServer[ConsumeResponse]

func _ConsumeService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConsumeServiceServer).Subscribe(m, &grpc.GenericServerStream[SubscribeRequest, ConsumeResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConsumeService_SubscribeServer = grpc.ServerStreamingServer[ConsumeResponse]

// ConsumeService_ServiceDesc is the grpc.ServiceDesc for ConsumeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConsumeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "goqueue.v1.ConsumeService",
	HandlerType: (*ConsumeServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Consume",
			Handler:       _ConsumeService_Consume_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _ConsumeService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "goqueue.proto",
}

const (
	AckService_Ack_FullMethodName              = "/goqueue.v1.AckService/Ack"
	AckService_Nack_FullMethodName             = "/goqueue.v1.AckService/Nack"
	AckService_Reject_FullMethodName           = "/goqueue.v1.AckService/Reject"
	AckService_ExtendVisibility_FullMethodName = "/goqueue.v1.AckService/ExtendVisibility"
	AckService_BatchAck_FullMethodName         = "/goqueue.v1.AckService/BatchAck"
)

// AckServiceClient is the client API for AckService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AckServiceClient interface {
	// Ack - Acknowledge successful processing
	Ack(ctx context.Context, in *AckRequest, opts ...grpc.CallOption) (*AckResponse, error)
	// Nack - Negative acknowledgment (retry later)
	Nack(ctx context.Context, in *NackRequest, opts ...grpc.CallOption) (*NackResponse, error)
	// Reject - Reject message (send to DLQ)
	Reject(ctx context.Context, in *RejectRequest, opts ...grpc.CallOption) (*RejectResponse, error)
	// ExtendVisibility - Extend processing time
	ExtendVisibility(ctx context.Context, in *ExtendVisibilityRequest, opts ...grpc.CallOption) (*ExtendVisibilityResponse, error)
	// BatchAck - Acknowledge multiple messages at once
	BatchAck(ctx context.Context, in *BatchAckRequest, opts ...grpc.CallOption) (*BatchAckResponse, error)
}

type ackServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAckServiceClient(cc grpc.ClientConnInterface) AckServiceClient {
	return &ackServiceClient{cc}
}

func (c *ackServiceClient) Ack(ctx context.Context, in *AckRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, AckService_Ack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ackServiceClient) Nack(ctx context.Context, in *NackRequest, opts ...grpc.CallOption) (*NackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NackResponse)
	err := c.cc.Invoke(ctx, AckService_Nack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ackServiceClient) Reject(ctx context.Context, in *RejectRequest, opts ...grpc.CallOption) (*RejectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RejectResponse)
	err := c.cc.Invoke(ctx, AckService_Reject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ackServiceClient) ExtendVisibility(ctx context.Context, in *ExtendVisibilityRequest, opts ...grpc.CallOption) (*ExtendVisibilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExtendVisibilityResponse)
	err := c.cc.Invoke(ctx, AckService_ExtendVisibility_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ackServiceClient) BatchAck(ctx context.Context, in *BatchAckRequest, opts ...grpc.CallOption) (*BatchAckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchAckResponse)
	err := c.cc.Invoke(ctx, AckService_BatchAck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AckServiceServer is the server API for AckService service.
// All implementations must embed UnimplementedAckServiceServer
// for forward compatibility.
type AckServiceServer interface {
	// Ack - Acknowledge successful processing
	Ack(context.Context, *AckRequest) (*AckResponse, error)
	// Nack - Negative acknowledgment (retry later)
	Nack(context.Context, *NackRequest) (*NackResponse, error)
	// Reject - Reject message (send to DLQ)
	Reject(context.Context, *RejectRequest) (*RejectResponse, error)
	// ExtendVisibility - Extend processing time
	ExtendVisibility(context.Context, *ExtendVisibilityRequest) (*ExtendVisibilityResponse, error)
	// BatchAck - Acknowledge multiple messages at once
	BatchAck(context.Context, *BatchAckRequest) (*BatchAckResponse, error)
	mustEmbedUnimplementedAckServiceServer()
}

// UnimplementedAckServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAckServiceServer struct{}

func (UnimplementedAckServiceServer) Ack(context.Context, *AckRequest) (*AckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Ack not implemented")
}
func (UnimplementedAckServiceServer) Nack(context.Context, *NackRequest) (*NackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Nack not implemented")
}
func (UnimplementedAckServiceServer) Reject(context.Context, *RejectRequest) (*RejectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Reject not implemented")
}
func (UnimplementedAckServiceServer) ExtendVisibility(context.Context, *ExtendVisibilityRequest) (*ExtendVisibilityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExtendVisibility not implemented")
}
func (UnimplementedAckServiceServer) BatchAck(context.Context, *BatchAckRequest) (*BatchAckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BatchAck not implemented")
}
func (UnimplementedAckServiceServer) mustEmbedUnimplementedAckServiceServer() {}
func (UnimplementedAckServiceServer) testEmbeddedByValue()                    {}

// UnsafeAckServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AckServiceServer will
// result in compilation errors.
type UnsafeAckServiceServer interface {
	mustEmbedUnimplementedAckServiceServer()
}

func RegisterAckServiceServer(s grpc.ServiceRegistrar, srv AckServiceServer) {
	// If the following call panics, it indicates UnimplementedAckServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AckService_ServiceDesc, srv)
}

func _AckService_Ack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AckServiceServer).Ack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AckService_Ack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AckServiceServer).Ack(ctx, req.(*AckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AckService_Nack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AckServiceServer).Nack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AckService_Nack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AckServiceServer).Nack(ctx, req.(*NackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AckService_Reject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RejectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AckServiceServer).Reject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AckService_Reject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AckServiceServer).Reject(ctx, req.(*RejectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AckService_ExtendVisibility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtendVisibilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AckServiceServer).ExtendVisibility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AckService_ExtendVisibility_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AckServiceServer).ExtendVisibility(ctx, req.(*ExtendVisibilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AckService_BatchAck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchAckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AckServiceServer).BatchAck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AckService_BatchAck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AckServiceServer).BatchAck(ctx, req.(*BatchAckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AckService_ServiceDesc is the grpc.ServiceDesc for AckService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AckService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "goqueue.v1.AckService",
	HandlerType: (*AckServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ack",
			Handler:    _AckService_Ack_Handler,
		},
		{
			MethodName: "Nack",
			Handler:    _AckService_Nack_Handler,
		},
		{
			MethodName: "Reject",
			Handler:    _AckService_Reject_Handler,
		},
		{
			MethodName: "ExtendVisibility",
			Handler:    _AckService_ExtendVisibility_Handler,
		},
		{
			MethodName: "BatchAck",
			Handler:    _AckService_BatchAck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "goqueue.proto",
}

const (
	OffsetService_CommitOffsets_FullMethodName = "/goqueue.v1.OffsetService/CommitOffsets"
	OffsetService_FetchOffsets_FullMethodName  = "/goqueue.v1.OffsetService/FetchOffsets"
	OffsetService_ResetOffsets_FullMethodName  = "/goqueue.v1.OffsetService/ResetOffsets"
)

// OffsetServiceClient is the client API for OffsetService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OffsetServiceClient interface {
	// CommitOffsets - Commit consumer offsets
	CommitOffsets(ctx context.Context, in *CommitOffsetsRequest, opts ...grpc.CallOption) (*CommitOffsetsResponse, error)
	// FetchOffsets - Get committed offsets
	FetchOffsets(ctx context.Context, in *FetchOffsetsRequest, opts ...grpc.CallOption) (*FetchOffsetsResponse, error)
	// ResetOffsets - Reset offsets to specific position
	ResetOffsets(ctx context.Context, in *ResetOffsetsRequest, opts ...grpc.CallOption) (*ResetOffsetsResponse, error)
}

type offsetServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOffsetServiceClient(cc grpc.ClientConnInterface) OffsetServiceClient {
	return &offsetServiceClient{cc}
}

func (c *offsetServiceClient) CommitOffsets(ctx context.Context, in *CommitOffsetsRequest, opts ...grpc.CallOption) (*CommitOffsetsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommitOffsetsResponse)
	err := c.cc.Invoke(ctx, OffsetService_CommitOffsets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offsetServiceClient) FetchOffsets(ctx context.Context, in *FetchOffsetsRequest, opts ...grpc.CallOption) (*FetchOffsetsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FetchOffsetsResponse)
	err := c.cc.Invoke(ctx, OffsetService_FetchOffsets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offsetServiceClient) ResetOffsets(ctx context.Context, in *ResetOffsetsRequest, opts ...grpc.CallOption) (*ResetOffsetsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetOffsetsResponse)
	err := c.cc.Invoke(ctx, OffsetService_ResetOffsets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OffsetServiceServer is the server API for OffsetService service.
// All implementations must embed UnimplementedOffsetServiceServer
// for forward compatibility.
type OffsetServiceServer interface {
	// CommitOffsets - Commit consumer offsets
	CommitOffsets(context.Context, *CommitOffsetsRequest) (*CommitOffsetsResponse, error)
	// FetchOffsets - Get committed offsets
	FetchOffsets(context.Context, *FetchOffsetsRequest) (*FetchOffsetsResponse, error)
	// ResetOffsets - Reset offsets to specific position
	ResetOffsets(context.Context, *ResetOffsetsRequest) (*ResetOffsetsResponse, error)
	mustEmbedUnimplementedOffsetServiceServer()
}

// UnimplementedOffsetServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOffsetServiceServer struct{}

func (UnimplementedOffsetServiceServer) CommitOffsets(context.Context, *CommitOffsetsRequest) (*CommitOffsetsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CommitOffsets not implemented")
}
func (UnimplementedOffsetServiceServer) FetchOffsets(context.Context, *FetchOffsetsRequest) (*FetchOffsetsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FetchOffsets not implemented")
}
func (UnimplementedOffsetServiceServer) ResetOffsets(context.Context, *ResetOffsetsRequest) (*ResetOffsetsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResetOffsets not implemented")
}
func (UnimplementedOffsetServiceServer) mustEmbedUnimplementedOffsetServiceServer() {}
func (UnimplementedOffsetServiceServer) testEmbeddedByValue()                       {}

// UnsafeOffsetServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OffsetServiceServer will
// result in compilation errors.
type UnsafeOffsetServiceServer interface {
	mustEmbedUnimplementedOffsetServiceServer()
}

func RegisterOffsetServiceServer(s grpc.ServiceRegistrar, srv OffsetServiceServer) {
	// If the following call panics, it indicates UnimplementedOffsetServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OffsetService_ServiceDesc, srv)
}

func _OffsetService_CommitOffsets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitOffsetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffsetServiceServer).CommitOffsets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OffsetService_CommitOffsets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffsetServiceServer).CommitOffsets(ctx, req.(*CommitOffsetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OffsetService_FetchOffsets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchOffsetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffsetServiceServer).FetchOffsets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OffsetService_FetchOffsets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffsetServiceServer).FetchOffsets(ctx, req.(*FetchOffsetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OffsetService_ResetOffsets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetOffsetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffsetServiceServer).ResetOffsets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OffsetService_ResetOffsets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffsetServiceServer).ResetOffsets(ctx, req.(*ResetOffsetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OffsetService_ServiceDesc is the grpc.ServiceDesc for OffsetService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OffsetService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "goqueue.v1.OffsetService",
	HandlerType: (*OffsetServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CommitOffsets",
			Handler:    _OffsetService_CommitOffsets_Handler,
		},
		{
			MethodName: "FetchOffsets",
			Handler:    _OffsetService_FetchOffsets_Handler,
		},
		{
			MethodName: "ResetOffsets",
			Handler:    _OffsetService_ResetOffsets_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "goqueue.proto",
}

const (
	HealthService_Check_FullMethodName = "/goqueue.v1.HealthService/Check"
	HealthService_Watch_FullMethodName = "/goqueue.v1.HealthService/Watch"
)

// HealthServiceClient is the client API for HealthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthServiceClient interface {
	// Check - Standard health check
	Check(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// Watch - Stream health status changes
	Watch(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HealthCheckResponse], error)
}

type healthServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthServiceClient(cc grpc.ClientConnInterface) HealthServiceClient {
	return &healthServiceClient{cc}
}

func (c *healthServiceClient) Check(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, HealthService_Check_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthServiceClient) Watch(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HealthCheckResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HealthService_ServiceDesc.Streams[0], HealthService_Watch_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[HealthCheckRequest, HealthCheckResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_WatchClient = grpc.ServerStreamingClient[HealthCheckResponse]

// HealthServiceServer is the server API for HealthService service.
// All implementations must embed UnimplementedHealthServiceServer
// for forward compatibility.
type HealthServiceServer interface {
	// Check - Standard health check
	Check(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	// Watch - Stream health status changes
	Watch(*HealthCheckRequest, grpc.ServerStreamingServer[HealthCheckResponse]) error
	mustEmbedUnimplementedHealthServiceServer()
}

// UnimplementedHealthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHealthServiceServer struct{}

func (UnimplementedHealthServiceServer) Check(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedHealthServiceServer) Watch(*HealthCheckRequest, grpc.ServerStreamingServer[HealthCheckResponse]) error {
	return status.Error(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedHealthServiceServer) mustEmbedUnimplementedHealthServiceServer() {}
func (UnimplementedHealthServiceServer) testEmbeddedByValue()                       {}

// UnsafeHealthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthServiceServer will
// result in compilation errors.
type UnsafeHealthServiceServer interface {
	mustEmbedUnimplementedHealthServiceServer()
}

func RegisterHealthServiceServer(s grpc.ServiceRegistrar, srv HealthServiceServer) {
	// If the following call panics, it indicates UnimplementedHealthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HealthService_ServiceDesc, srv)
}

func _HealthService_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthService_Check_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).Check(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthService_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HealthCheckRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HealthServiceServer).Watch(m, &grpc.GenericServerStream[HealthCheckRequest, HealthCheckResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_WatchServer = grpc.ServerStreamingServer[HealthCheckResponse]

// HealthService_ServiceDesc is the grpc.ServiceDesc for HealthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "goqueue.v1.HealthService",
	HandlerType: (*HealthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Check",
			Handler:    _HealthService_Check_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _HealthService_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "goqueue.proto",
}
